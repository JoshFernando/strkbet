import * as starknet from "./starknet-types";
import { StarknetWrapper } from "./starknet-wrappers";
import { Wallet } from "hardhat/types";
/**
 * According to: https://starknet.io/docs/hello_starknet/intro.html#interact-with-the-contract
 * Not using an enum to avoid code duplication and reverse mapping.
 */
export declare type TxStatus = 
/** The transaction passed the validation and entered the pending block. */
"PENDING"
/** The transaction has not been received yet (i.e., not written to storage). */
 | "NOT_RECEIVED"
/** The transaction was received by the operator. */
 | "RECEIVED"
/** The transaction failed validation and thus was skipped. */
 | "REJECTED"
/** The transaction passed the validation and entered an actual created block. */
 | "ACCEPTED_ON_L2"
/** The transaction was accepted on-chain. */
 | "ACCEPTED_ON_L1";
export declare type AccountImplementationType = "OpenZeppelin";
export declare type InvokeResponse = string;
export declare type StarknetContractFactoryConfig = StarknetContractConfig & {
    metadataPath: string;
};
export declare type TxFailureReason = {
    code: string;
    error_message: string;
    tx_id: string;
};
export interface StarknetContractConfig {
    starknetWrapper: StarknetWrapper;
    abiPath: string;
    networkID: string;
    gatewayUrl: string;
    feederGatewayUrl: string;
}
export declare type Numeric = number | bigint;
/**
 * Object whose keys are strings (names) and values are any object.
 */
export interface StringMap {
    [key: string]: any;
}
export declare type Choice = "call" | "invoke";
export declare function extractTxHash(response: string): string;
/**
 * The object returned by starknet tx_status.
 */
declare type StatusObject = {
    block_hash: string;
    tx_status: TxStatus;
    tx_failure_reason?: TxFailureReason;
};
export declare function isTxAccepted(statusObject: StatusObject): boolean;
export declare function iterativelyCheckStatus(txHash: string, starknetWrapper: StarknetWrapper, gatewayUrl: string, feederGatewayUrl: string, resolve: (status: string) => void, reject: (reason?: any) => void): Promise<void>;
export interface DeployOptions {
    salt?: string;
}
export interface InvokeOptions {
    signature?: Array<Numeric>;
    wallet?: Wallet;
}
export interface CallOptions {
    signature?: Array<Numeric>;
    wallet?: Wallet;
    blockNumber?: string;
}
export declare class StarknetContractFactory {
    private starknetWrapper;
    private abi;
    private abiPath;
    private constructorAbi;
    private metadataPath;
    private networkID;
    private gatewayUrl;
    private feederGatewayUrl;
    constructor(config: StarknetContractFactoryConfig);
    /**
     * Deploy a contract instance to a new address.
     * Optionally pass constructor arguments.
     *
     * E.g. if there is a function
     * ```text
     * @constructor
     * func constructor{
     *     syscall_ptr : felt*,
     *     pedersen_ptr : HashBuiltin*,
     *     range_check_ptr
     * } (initial_balance : felt):
     *     balance.write(initial_balance)
     *     return ()
     * end
     * ```
     * this plugin allows you to call it like:
     * ```
     * const contractFactory = ...;
     * const instance = await contractFactory.deploy({ initial_balance: 100 });
     * ```
     * @param constructorArguments constructor arguments of Starknet contract
     * @param options optional additions to deploying
     * @returns the newly created instance
     */
    deploy(constructorArguments?: StringMap, options?: DeployOptions): Promise<StarknetContract>;
    private handleConstructorArguments;
    /**
     * Returns a contract instance with set address.
     * No address validity checks are performed.
     * @param address the address of a previously deployed contract
     * @returns the contract instance at the provided address
     */
    getContractAt(address: string): StarknetContract;
    getAbiPath(): string;
}
export declare class StarknetContract {
    private starknetWrapper;
    private abi;
    private abiPath;
    address: string;
    private networkID;
    private gatewayUrl;
    private feederGatewayUrl;
    constructor(config: StarknetContractConfig);
    private invokeOrCall;
    /**
     * Invoke the function by name and optionally provide arguments in an array.
     * For a usage example @see {@link call}
     * @param functionName
     * @param args arguments to Starknet contract function
     * @options optional additions to invoking
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    invoke(functionName: string, args?: StringMap, options?: InvokeOptions): Promise<InvokeResponse>;
    /**
     * Call the function by name and optionally provide arguments in an array.
     *
     * E.g. If your contract has a function
     * ```text
     * func double_sum(x: felt, y: felt) -> (res: felt):
     *     return (res=(x + y) * 2)
     * end
     * ```
     * then you would call it like:
     * ```typescript
     * const contract = ...;
     * const { res: sum } = await contract.call("double_sum", { x: 2, y: 3 });
     * console.log(sum);
     * ```
     * which would result in:
     * ```text
     * > 10n
     * ```
     * @param functionName
     * @param args arguments to Starknet contract function
     * @param options optional additions to calling
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    call(functionName: string, args?: StringMap, options?: CallOptions): Promise<StringMap>;
    /**
     * Returns the ABI of the whole contract.
     * @returns contract ABI
     */
    getAbi(): starknet.Abi;
    /**
     * Adapt structured `args` to unstructured array expected by e.g. Starknet CLI.
     * @param functionName the name of the function to adapt
     * @param args structured args
     * @returns unstructured args
     */
    adaptInput(functionName: string, args?: StringMap): string[];
    /**
     * Adapt unstructured `rawResult` to a structured object.
     * @param functionName the name of the function that produced the output
     * @param rawResult the function output as as unparsed space separated string
     * @returns structured output
     */
    adaptOutput(functionName: string, rawResult: string): StringMap;
}
export {};
