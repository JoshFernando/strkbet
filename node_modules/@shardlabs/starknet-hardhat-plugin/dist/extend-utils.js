"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountFromAddressUtil = exports.deployAccountUtil = exports.getWalletUtil = exports.bigIntToShortStringUtil = exports.shortStringToBigIntUtil = exports.getContractFactoryUtil = void 0;
const plugins_1 = require("hardhat/plugins");
const path = __importStar(require("path"));
const constants_1 = require("./constants");
const types_1 = require("./types");
const account_1 = require("./account");
const utils_1 = require("./utils");
function getContractFactoryUtil(hre, contractPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const artifactsPath = hre.config.paths.starknetArtifacts;
        (0, utils_1.checkArtifactExists)(artifactsPath);
        contractPath = contractPath.replace(/\.[^/.]+$/, ""); // remove extension
        const metadataSearchTarget = path.join(`${contractPath}.cairo`, `${path.basename(contractPath)}.json`);
        const metadataPath = yield (0, utils_1.findPath)(artifactsPath, metadataSearchTarget);
        if (!metadataPath) {
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `Could not find metadata for ${contractPath}`);
        }
        const abiSearchTarget = path.join(`${contractPath}.cairo`, `${path.basename(contractPath)}${constants_1.ABI_SUFFIX}`);
        const abiPath = yield (0, utils_1.findPath)(artifactsPath, abiSearchTarget);
        if (!abiPath) {
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `Could not find ABI for ${contractPath}`);
        }
        return new types_1.StarknetContractFactory({
            starknetWrapper: hre.starknetWrapper,
            metadataPath,
            abiPath,
            networkID: hre.config.starknet.network,
            gatewayUrl: hre.config.starknet.networkUrl,
            feederGatewayUrl: hre.config.starknet.networkUrl
        });
    });
}
exports.getContractFactoryUtil = getContractFactoryUtil;
function shortStringToBigIntUtil(convertableString) {
    if (!convertableString) {
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "A non-empty string must be provided");
    }
    if (convertableString.length > constants_1.SHORT_STRING_MAX_CHARACTERS) {
        const msg = `Short strings must have a max of ${constants_1.SHORT_STRING_MAX_CHARACTERS} characters.`;
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
    }
    const invalidChars = {};
    const charArray = [];
    for (const c of convertableString.split("")) {
        const charCode = c.charCodeAt(0);
        if (charCode > 127) {
            invalidChars[c] = true;
        }
        charArray.push(charCode.toString(16));
    }
    const invalidCharArray = Object.keys(invalidChars);
    if (invalidCharArray.length) {
        const msg = `Non-standard-ASCII character${invalidCharArray.length === 1 ? "" : "s"}: ${invalidCharArray.join(", ")}`;
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
    }
    return BigInt("0x" + charArray.join(""));
}
exports.shortStringToBigIntUtil = shortStringToBigIntUtil;
function bigIntToShortStringUtil(convertableBigInt) {
    return Buffer.from(convertableBigInt.toString(16), "hex").toString();
}
exports.bigIntToShortStringUtil = bigIntToShortStringUtil;
function getWalletUtil(name, hre) {
    const wallet = hre.config.starknet.wallets[name];
    if (!wallet) {
        const available = Object.keys(hre.config.starknet.wallets).join(", ");
        const msg = `Invalid wallet name provided: ${name}.\nValid wallets: ${available}`;
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
    }
    wallet.accountPath = (0, utils_1.getAccountPath)(wallet.accountPath, hre);
    return wallet;
}
exports.getWalletUtil = getWalletUtil;
function deployAccountUtil(accountType, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        let account;
        switch (accountType) {
            case "OpenZeppelin":
                account = yield account_1.OpenZeppelinAccount.deployFromABI(hre);
                break;
            default:
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Invalid account type requested.");
        }
        return account;
    });
}
exports.deployAccountUtil = deployAccountUtil;
function getAccountFromAddressUtil(address, privateKey, accountType, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        let account;
        switch (accountType) {
            case "OpenZeppelin":
                account = yield account_1.OpenZeppelinAccount.getAccountFromAddress(address, privateKey, hre);
                break;
            default:
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Invalid account type requested.");
        }
        return account;
    });
}
exports.getAccountFromAddressUtil = getAccountFromAddressUtil;
//# sourceMappingURL=extend-utils.js.map