"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
require("./type-extensions");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const starknet_wrappers_1 = require("./starknet-wrappers");
const task_actions_1 = require("./task-actions");
const extend_utils_1 = require("./extend-utils");
const devnet_utils_1 = require("./devnet-utils");
// copy all user-defined cairo settings; other extendConfig calls will overwrite if needed
(0, config_1.extendConfig)((config, userConfig) => {
    if (userConfig.starknet) {
        config.starknet = JSON.parse(JSON.stringify(userConfig.starknet));
    }
    if (!config.starknet) {
        config.starknet = {};
    }
});
// add sources path
(0, config_1.extendConfig)((config, userConfig) => {
    let newPath;
    if (userConfig.paths && userConfig.paths.starknetSources) {
        const userPath = userConfig.paths.starknetSources;
        if (path.isAbsolute(userPath)) {
            newPath = userPath;
        }
        else {
            newPath = path.normalize(path.join(config.paths.root, userPath));
        }
        config.paths.starknetSources = userConfig.paths.starknetSources;
    }
    else {
        const defaultPath = path.join(config.paths.root, constants_1.DEFAULT_STARKNET_SOURCES_PATH);
        newPath = defaultPath;
    }
    config.paths.starknetSources = newPath;
});
// add artifacts path
(0, config_1.extendConfig)((config, userConfig) => {
    let newPath;
    if (userConfig.paths && userConfig.paths.starknetArtifacts) {
        const userPath = userConfig.paths.starknetArtifacts;
        if (path.isAbsolute(userPath)) {
            newPath = userPath;
        }
        else {
            newPath = path.normalize(path.join(config.paths.root, userPath));
        }
        config.paths.starknetArtifacts = userConfig.paths.starknetArtifacts;
    }
    else {
        const defaultPath = path.join(config.paths.root, constants_1.DEFAULT_STARKNET_ARTIFACTS_PATH);
        newPath = defaultPath;
    }
    config.paths.starknetArtifacts = newPath;
});
// add url to alpha network
(0, config_1.extendConfig)((config) => {
    if (!config.networks.alpha) {
        config.networks.alpha = (0, utils_1.getDefaultHttpNetworkConfig)(constants_1.ALPHA_URL, constants_1.VOYAGER_GOERLI_CONTRACT_API_URL);
    }
    if (!config.networks.alphaMainnet) {
        config.networks.alphaMainnet = (0, utils_1.getDefaultHttpNetworkConfig)(constants_1.ALPHA_MAINNET_URL, constants_1.VOYAGER_MAINNET_CONTRACT_API_URL);
    }
});
// set network as specified in userConfig
(0, config_1.extendConfig)((config, userConfig) => {
    if (userConfig.starknet && userConfig.starknet.network) {
        config.starknet.network = userConfig.starknet.network;
    }
    else {
        config.starknet.network = constants_1.DEFAULT_STARKNET_NETWORK;
    }
    const networkConfig = (0, utils_1.getNetwork)(config.starknet.network, config.networks, "starknet.network in hardhat.config");
    config.starknet.networkUrl = networkConfig.url;
});
// add venv wrapper or docker wrapper of starknet
(0, config_1.extendEnvironment)((hre) => {
    const venvPath = hre.config.starknet.venv;
    if (venvPath) {
        if (hre.config.starknet.dockerizedVersion) {
            const msg = "Error in config file. Only one of (starknet.dockerizedVersion, starknet.venv) can be specified.";
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
        }
        hre.starknetWrapper = new starknet_wrappers_1.VenvWrapper(venvPath);
    }
    else {
        const repository = constants_1.DOCKER_REPOSITORY;
        const tag = hre.config.starknet.dockerizedVersion || constants_1.DEFAULT_DOCKER_IMAGE_TAG;
        hre.starknetWrapper = new starknet_wrappers_1.DockerWrapper({ repository, tag });
    }
});
(0, config_1.task)("starknet-compile", "Compiles Starknet contracts")
    .addOptionalVariadicPositionalParam("paths", "The paths to be used for deployment.\n" +
    "Each of the provided paths is recursively looked into while searching for compilation artifacts.\n" +
    "If no paths are provided, the default contracts directory is traversed.")
    .addOptionalParam("cairoPath", "Allows specifying the locations of imported files, if necessary.\n" +
    "Separate them with a colon (:), e.g. --cairo-path='path/to/lib1:path/to/lib2'")
    .setAction(task_actions_1.starknetCompileAction);
(0, config_1.task)("starknet-deploy", "Deploys Starknet contracts which have been compiled.")
    .addFlag("wait", "Wait for deployment transaction to be at least ACCEPTED_ON_L2")
    .addOptionalParam("starknetNetwork", "The network version to be used (e.g. alpha)")
    .addOptionalParam("gatewayUrl", `The URL of the gateway to be used (e.g. ${constants_1.ALPHA_URL})`)
    .addOptionalParam("inputs", "Space separated values forming constructor input.\n" +
    `Pass them as a single string; e.g. --inputs "${"1 2 3"}"\n` +
    "You would typically use this feature when deploying a single contract.\n" +
    "If you're deploying multiple contracts, they'll all use the same input.")
    .addOptionalParam("salt", "An optional salt controlling where the contract will be deployed.\n" +
    "The contract deployment address is determined by the hash of contract, salt and caller.\n" +
    "If the salt is not supplied, the contract will be deployed with a random salt.")
    .addOptionalVariadicPositionalParam("paths", "The paths to be used for deployment.\n" +
    "Each of the provided paths is recursively looked into while searching for compilation artifacts.\n" +
    "If no paths are provided, the default artifacts directory is traversed.")
    .setAction(task_actions_1.starknetDeployAction);
(0, config_1.extendEnvironment)((hre) => {
    hre.starknet = {
        getContractFactory: (contractPath) => __awaiter(void 0, void 0, void 0, function* () {
            const contractFactory = yield (0, extend_utils_1.getContractFactoryUtil)(hre, contractPath);
            return contractFactory;
        }),
        shortStringToBigInt: (convertableString) => {
            const convertedString = (0, extend_utils_1.shortStringToBigIntUtil)(convertableString);
            return convertedString;
        },
        bigIntToShortString: (convertableBigInt) => {
            const convertedBigInt = (0, extend_utils_1.bigIntToShortStringUtil)(convertableBigInt);
            return convertedBigInt;
        },
        getWallet: (name) => {
            const wallet = (0, extend_utils_1.getWalletUtil)(name, hre);
            return wallet;
        },
        devnet: (0, plugins_1.lazyObject)(() => new devnet_utils_1.DevnetUtils(hre)),
        deployAccount: (accountType) => __awaiter(void 0, void 0, void 0, function* () {
            const account = yield (0, extend_utils_1.deployAccountUtil)(accountType, hre);
            return account;
        }),
        getAccountFromAddress: (address, privateKey, accountType) => __awaiter(void 0, void 0, void 0, function* () {
            const account = yield (0, extend_utils_1.getAccountFromAddressUtil)(address, privateKey, accountType, hre);
            return account;
        })
    };
});
(0, config_1.task)("starknet-verify", "Verifies a contract on a Starknet network.")
    .addOptionalParam("starknetNetwork", "The network version to be used (e.g. alpha)")
    .addParam("path", "The path of the main cairo contract (e.g. contracts/contract.cairo)")
    .addParam("address", "The address where the contract is deployed")
    .addOptionalVariadicPositionalParam("paths", "The paths of the dependencies of the contract specified in --path" +
    "All dependencies should be in the same folder as the contract." +
    "e.g. path/to/dependency1 path/to/dependency2")
    .setAction(task_actions_1.starknetVoyagerAction);
(0, config_1.task)("starknet-invoke", "Invokes a function on a contract in the provided address.")
    .addFlag("wait", "Wait for invoke transaction to be at least ACCEPTED_ON_L2")
    .addOptionalParam("starknetNetwork", "The network version to be used (e.g. alpha)")
    .addOptionalParam("gatewayUrl", `The URL of the gateway to be used (e.g. ${constants_1.ALPHA_URL})`)
    .addParam("contract", "The name of the contract to invoke from")
    .addParam("function", "The name of the function to invoke")
    .addParam("address", "The address where the contract is deployed")
    .addOptionalParam("inputs", "Space separated values forming function input.\n" +
    `Pass them as a single string; e.g. --inputs "${"1 2 3"}"`)
    .addOptionalParam("signature", "The call signature")
    .addOptionalParam("wallet", "The wallet to use, defined in the 'hardhat.config' file. If omitted, the '--no_wallet' flag will be passed when invoking.")
    .setAction(task_actions_1.starknetInvokeAction);
(0, config_1.task)("starknet-call", "Invokes a function on a contract in the provided address.")
    .addOptionalParam("starknetNetwork", "The network version to be used (e.g. alpha)")
    .addOptionalParam("gatewayUrl", `The URL of the gateway to be used (e.g. ${constants_1.ALPHA_URL})`)
    .addParam("contract", "The name of the contract to invoke from")
    .addParam("function", "The name of the function to invoke")
    .addParam("address", "The address where the contract is deployed")
    .addOptionalParam("inputs", "Space separated values forming function input.\n" +
    `Pass them as a single string; e.g. --inputs "${"1 2 3"}"`)
    .addOptionalParam("signature", "The call signature")
    .addOptionalParam("wallet", "The wallet to use, defined in the 'hardhat.config' file. If omitted, the '--no_wallet' flag will be passed when calling.")
    .addOptionalParam("blockNumber", "The number of the block to call. If omitted, the pending block will be queried.")
    .setAction(task_actions_1.starknetCallAction);
(0, config_1.task)("starknet-deploy-account", "Deploys a new account according to the parameters.")
    .addParam("wallet", "The wallet object to use, defined in the 'hardhat.config' file")
    .addParam("starknetNetwork", "The network version to be used (e.g. alpha)")
    .setAction(task_actions_1.starknetDeployAccountAction);
const STARKNET_NETWORK_DESCRIPTION = "Specify the starknet-network to be used; overrides the value from hardhat.config";
(0, config_1.task)("test")
    .addOptionalParam("starknetNetwork", STARKNET_NETWORK_DESCRIPTION)
    .setAction(task_actions_1.starknetTestAction);
//# sourceMappingURL=index.js.map