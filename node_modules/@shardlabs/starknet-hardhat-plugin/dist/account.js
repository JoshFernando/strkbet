"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenZeppelinAccount = exports.Account = void 0;
const constants_1 = require("./constants");
const plugins_1 = require("hardhat/plugins");
const starknet_1 = require("starknet");
const ellipticCurve = __importStar(require("starknet/utils/ellipticCurve"));
const number_1 = require("starknet/utils/number");
const account_utils_1 = require("./account-utils");
/**
 * Representation of an Account.
 * Multiple implementations can exist, each will be defined by an extension of this Abstract class
 */
class Account {
    constructor(starknetContract, privateKey, publicKey, keyPair) {
        this.starknetContract = starknetContract;
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        this.keyPair = keyPair;
    }
}
exports.Account = Account;
/**
 * Wrapper for the OpenZeppelin implementation of an Account
 */
class OpenZeppelinAccount extends Account {
    constructor(starknetContract, privateKey, publicKey, keyPair) {
        super(starknetContract, privateKey, publicKey, keyPair);
    }
    /**
     * Invoke a function of a contract through this account.
     * @param toContract the contract being being invoked
     * @param functionName the name of the function to invoke
     * @param calldata the calldata to be passed to the function
     */
    invoke(toContract, functionName, calldata = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.invokeOrCall("invoke", toContract, functionName, calldata)).toString();
        });
    }
    /**
     * Call a function of a contract through this account.
     * @param toContract the contract being being called
     * @param functionName the name of the function to call
     * @param calldata the calldata to be passed to the function
     */
    call(toContract, functionName, calldata) {
        return __awaiter(this, void 0, void 0, function* () {
            const { response } = (yield this.invokeOrCall("call", toContract, functionName, calldata));
            return toContract.adaptOutput(functionName, response.join(" "));
        });
    }
    invokeOrCall(choice, toContract, functionName, calldata) {
        return __awaiter(this, void 0, void 0, function* () {
            const { res: nonce } = yield this.starknetContract.call("get_nonce");
            const selector = starknet_1.hash.starknetKeccak(functionName);
            const adaptedCalldata = toContract.adaptInput(functionName, calldata);
            const signature = (0, account_utils_1.sign)(this.keyPair, this.starknetContract.address, nonce.toString(), selector.toString(), toContract.address, adaptedCalldata);
            const args = {
                to: BigInt(toContract.address),
                selector,
                calldata: adaptedCalldata,
                nonce
            };
            const options = { signature };
            return this.starknetContract[choice](OpenZeppelinAccount.EXECUTION_FUNCTION_NAME, args, options);
        });
    }
    static deployFromABI(hre) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractPath = yield (0, account_utils_1.handleAccountContractArtifacts)(OpenZeppelinAccount.ACCOUNT_TYPE_NAME, OpenZeppelinAccount.ACCOUNT_ARTIFACTS_NAME, hre);
            const starkPrivateKey = (0, account_utils_1.generateRandomStarkPrivateKey)();
            const keyPair = ellipticCurve.getKeyPair(starkPrivateKey);
            const publicKey = ellipticCurve.getStarkKey(keyPair);
            const contractFactory = yield hre.starknet.getContractFactory(contractPath);
            const contract = yield contractFactory.deploy({ _public_key: BigInt(publicKey) });
            const privateKey = "0x" + starkPrivateKey.toString(16);
            return new OpenZeppelinAccount(contract, privateKey, publicKey, keyPair);
        });
    }
    static getAccountFromAddress(address, privateKey, hre) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractPath = yield (0, account_utils_1.handleAccountContractArtifacts)(OpenZeppelinAccount.ACCOUNT_TYPE_NAME, OpenZeppelinAccount.ACCOUNT_ARTIFACTS_NAME, hre);
            const contractFactory = yield hre.starknet.getContractFactory(contractPath);
            const contract = contractFactory.getContractAt(address);
            const { res: expectedPubKey } = yield contract.call("get_public_key");
            const keyPair = ellipticCurve.getKeyPair((0, number_1.toBN)(privateKey.substring(2), "hex"));
            const publicKey = ellipticCurve.getStarkKey(keyPair);
            if (BigInt(publicKey) !== expectedPubKey) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "The provided private key is not compatible with the public key stored in the contract.");
            }
            return new OpenZeppelinAccount(contract, privateKey, publicKey, keyPair);
        });
    }
}
exports.OpenZeppelinAccount = OpenZeppelinAccount;
OpenZeppelinAccount.EXECUTION_FUNCTION_NAME = "execute";
OpenZeppelinAccount.ACCOUNT_TYPE_NAME = "OpenZeppelinAccount";
OpenZeppelinAccount.ACCOUNT_ARTIFACTS_NAME = "Account";
//# sourceMappingURL=account.js.map