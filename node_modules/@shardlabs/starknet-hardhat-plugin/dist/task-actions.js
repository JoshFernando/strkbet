"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.starknetTestAction = exports.starknetDeployAccountAction = exports.starknetCallAction = exports.starknetInvokeAction = exports.starknetVoyagerAction = exports.starknetDeployAction = exports.starknetCompileAction = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const axios_1 = __importDefault(require("axios"));
const plugins_1 = require("hardhat/plugins");
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_1 = require("./utils");
const extend_utils_1 = require("./extend-utils");
function checkSourceExists(sourcePath) {
    if (!fs.existsSync(sourcePath)) {
        const msg = `Source expected to be at ${sourcePath}, but not found.`;
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
    }
}
/**
 * Transfers logs and generates a return status code.
 *
 * @param executed The process result of running the container
 * @returns 0 if succeeded, 1 otherwise
 */
function processExecuted(executed, logStatus) {
    if (executed.stdout.length) {
        console.log((0, utils_1.adaptLog)(executed.stdout.toString()));
    }
    if (executed.stderr.length) {
        // synchronize param names reported by actual CLI with param names used by this plugin
        const err = executed.stderr.toString();
        const replacedErr = (0, utils_1.adaptLog)(err);
        console.error(replacedErr);
    }
    if (logStatus) {
        const finalMsg = executed.statusCode ? "Failed" : "Succeeded";
        console.log(`\t${finalMsg}\n`);
    }
    return executed.statusCode ? 1 : 0;
}
function isStarknetCompilationArtifact(filePath) {
    const content = fs.readFileSync(filePath).toString();
    let parsed = null;
    try {
        parsed = JSON.parse(content);
    }
    catch (err) {
        return false;
    }
    return !!parsed.entry_points_by_type;
}
/**
 * First deletes the file if it already exists. Then creates an empty file at the provided path.
 * Unlinking/deleting is necessary if user switched from docker to venv.
 * @param filePath the file to be recreated
 */
function initializeFile(filePath) {
    if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
    fs.closeSync(fs.openSync(filePath, "w"));
}
function getFileName(filePath) {
    return path.basename(filePath, path.extname(filePath));
}
/**
 * Extracts gatewayUrl from args or process.env.STARKNET_NETWORK.
 *
 * @param args the object containing CLI args
 * @param hre environment whose networks and starknet.network are accessed
 * @returns the URL of the gateway to be used; can return `undefined` if `required` set to `false`
 */
function getGatewayUrl(args, hre) {
    const gatewayUrl = args.gatewayUrl;
    const networkName = args.starknetNetwork || process.env.STARKNET_NETWORK;
    if (gatewayUrl && !networkName) {
        return gatewayUrl;
    }
    if (gatewayUrl && networkName) {
        const msg = "Only one of starknet-network and gateway-url should be provided.";
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
    }
    if (!networkName) {
        // we already know no gatewayUrl is provided
        const msg = "No starknet-network or gateway-url provided.";
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
    }
    const network = (0, utils_1.getNetwork)(networkName, hre.config.networks, "starknet-network");
    return network.url;
}
function starknetCompileAction(args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = hre.config.paths.root;
        const rootRegex = new RegExp("^" + root);
        const defaultSourcesPath = hre.config.paths.starknetSources;
        const sourcesPaths = args.paths || [defaultSourcesPath];
        const artifactsPath = hre.config.paths.starknetArtifacts;
        const cairoPaths = [defaultSourcesPath, root];
        if (args.cairoPath) {
            args.cairoPath.split(":").forEach((path) => {
                cairoPaths.push(path);
            });
        }
        if (hre.config.paths.cairoPaths) {
            hre.config.paths.cairoPaths.forEach((path) => {
                cairoPaths.push(path);
            });
        }
        for (let i = 0; i < cairoPaths.length; i++) {
            if (!path.isAbsolute(cairoPaths[i])) {
                cairoPaths[i] = path.normalize(path.join(root, cairoPaths[i]));
            }
        }
        const cairoPath = cairoPaths.join(":");
        let statusCode = 0;
        for (let sourcesPath of sourcesPaths) {
            if (!path.isAbsolute(sourcesPath)) {
                sourcesPath = path.normalize(path.join(root, sourcesPath));
            }
            checkSourceExists(sourcesPath);
            const files = yield (0, utils_1.traverseFiles)(sourcesPath, "*.cairo");
            for (const file of files) {
                console.log("Compiling", file);
                const suffix = file.replace(rootRegex, "");
                const fileName = getFileName(suffix);
                const dirPath = path.join(artifactsPath, suffix);
                const outputPath = path.join(dirPath, `${fileName}.json`);
                const abiPath = path.join(dirPath, `${fileName}${constants_1.ABI_SUFFIX}`);
                fs.mkdirSync(dirPath, { recursive: true });
                initializeFile(outputPath);
                initializeFile(abiPath);
                const executed = yield hre.starknetWrapper.compile({
                    file,
                    output: outputPath,
                    abi: abiPath,
                    cairoPath
                });
                statusCode += processExecuted(executed, true);
            }
        }
        if (statusCode) {
            const msg = `Failed compilation of ${statusCode} contract${statusCode === 1 ? "" : "s"}.`;
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
        }
    });
}
exports.starknetCompileAction = starknetCompileAction;
function starknetDeployAction(args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const gatewayUrl = getGatewayUrl(args, hre);
        const defaultArtifactsPath = hre.config.paths.starknetArtifacts;
        const artifactsPaths = args.paths || [defaultArtifactsPath];
        const intRegex = new RegExp(/^-?\d+$/);
        let statusCode = 0;
        const txHashes = [];
        for (let artifactsPath of artifactsPaths) {
            if (intRegex.test(artifactsPath)) {
                console.warn(`WARNING: found an integer "${artifactsPath}" as an artifact path. Make sure that all inputs are passed within a single string (e.g --inputs "10 20 30")`);
            }
            // Check if input is the name of the contract and not a path
            if (artifactsPath === path.basename(artifactsPath)) {
                const metadataSearchTarget = path.join(`${artifactsPath}.cairo`, `${path.basename(artifactsPath)}.json`);
                artifactsPath = yield (0, utils_1.findPath)(defaultArtifactsPath, metadataSearchTarget);
            }
            else if (!path.isAbsolute(artifactsPath)) {
                artifactsPath = path.normalize(path.join(hre.config.paths.root, artifactsPath));
            }
            (0, utils_1.checkArtifactExists)(artifactsPath);
            const paths = yield (0, utils_1.traverseFiles)(artifactsPath, "*.json");
            const files = paths.filter(isStarknetCompilationArtifact);
            for (const file of files) {
                console.log("Deploying", file);
                const executed = yield hre.starknetWrapper.deploy({
                    contract: file,
                    gatewayUrl,
                    inputs: args.inputs ? args.inputs.split(/\s+/) : undefined,
                    salt: args.salt ? args.salt : undefined
                });
                if (args.wait) {
                    const execResult = processExecuted(executed, false);
                    if (execResult == 0) {
                        txHashes.push((0, types_1.extractTxHash)(executed.stdout.toString()));
                    }
                    statusCode += execResult;
                }
                else {
                    statusCode += processExecuted(executed, true);
                }
            }
        }
        if (args.wait) {
            // If the "wait" flag was passed as an argument, check the previously stored transaction hashes for their statuses
            console.log(`Checking deployment transaction${txHashes.length === 1 ? "" : "s"}...`);
            const promises = txHashes.map((hash) => new Promise((resolve, reject) => (0, types_1.iterativelyCheckStatus)(hash, hre.starknetWrapper, gatewayUrl, gatewayUrl, (status) => {
                console.log(`Deployment transaction ${hash} is now ${status}`);
                resolve();
            }, (error) => {
                console.log(`Deployment transaction ${hash} is REJECTED`);
                reject(error);
            })));
            yield Promise.allSettled(promises);
        }
        if (statusCode) {
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `Failed deployment of ${statusCode} contracts`);
        }
    });
}
exports.starknetDeployAction = starknetDeployAction;
/**
 * Extracts the verification URL assigned to the network provided.
 * If no `networkName` is provided, defaults to Alpha testnet.
 * If `networkName` is provided, but not supported for verification, an error is thrown.
 * @param networkName the name of the network
 * @param hre the runtime environment from which network data is extracted
 * @param origin short string describing where/how `networkName` was specified
 */
function getVerificationUrl(networkName, hre, origin) {
    networkName || (networkName = constants_1.ALPHA_TESTNET);
    const network = (0, utils_1.getNetwork)(networkName, hre.config.networks, origin);
    if (!network.verificationUrl) {
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `Network ${networkName} does not support Voyager verification.`);
    }
    return network.verificationUrl;
}
function starknetVoyagerAction(args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const verificationUrl = getVerificationUrl(args.starknetNetwork, hre, "starknet-network");
        const voyagerUrl = `${verificationUrl}${args.address}/code`;
        let isVerified = false;
        try {
            const resp = yield axios_1.default.get(voyagerUrl, {
                headers: {
                    Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                    "Content-Type": "application/json"
                }
            });
            const data = resp.data;
            if (data.contract) {
                if (data.contract.length > 0 || Object.keys(data.contract).length > 0) {
                    isVerified = true;
                }
            }
        }
        catch (error) {
            const msg = `Something went wrong when trying to verify the code at address ${args.address}`;
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
        }
        if (isVerified) {
            console.log(`Contract at address ${args.address} has already been verified`);
        }
        else {
            yield handleContractVerification(args, voyagerUrl, hre);
        }
    });
}
exports.starknetVoyagerAction = starknetVoyagerAction;
function handleContractVerification(args, voyagerUrl, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        // Set main contract path
        let contractPath = args.path;
        if (!path.isAbsolute(contractPath)) {
            contractPath = path.normalize(path.join(hre.config.paths.root, contractPath));
            if (!fs.existsSync(contractPath)) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `File ${contractPath} does not exist`);
            }
        }
        // The other option for the formData would be to add a new dependency 'form-data', but the URLSearchParams works exactly the same
        const bodyFormData = new URLSearchParams();
        bodyFormData.append("contract-name", path.parse(contractPath).base);
        // If the contract has dependencies, insert them into the form
        if (args.paths) {
            handleMultiPartContractVerification(bodyFormData, contractPath, args, hre);
        }
        else {
            handleSingleContractVerification(bodyFormData, contractPath);
        }
        yield axios_1.default.post(voyagerUrl, bodyFormData).catch((error) => {
            switch (error.response.status) {
                case 400: {
                    const msg = `Contract at address ${args.address} does not match the provided code`;
                    throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
                }
                case 500: {
                    const msg = `There is no contract deployed at address ${args.address}, or the transaction was not finished`;
                    throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
                }
                default: {
                    const msg = `Something went wrong when trying to verify the code at address ${args.address}`;
                    throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
                }
            }
        });
        console.log(`Contract has been successfuly verified at address ${args.address}`);
    });
}
function handleSingleContractVerification(bodyFormData, contractPath) {
    const file = fs.readFileSync(contractPath);
    const fileContent = file.toString().split(/\r?\n|\r/);
    bodyFormData.append("code", JSON.stringify(fileContent));
}
function handleMultiPartContractVerification(bodyFormData, contractPath, args, hre) {
    bodyFormData.append("filename", path.parse(contractPath).base);
    bodyFormData.append("file", fs.readFileSync(contractPath).toString());
    args.paths.forEach(function (item, index) {
        if (!path.isAbsolute(item)) {
            args.paths[index] = path.normalize(path.join(hre.config.paths.root, item));
            if (!fs.existsSync(args.paths[index])) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `File ${args.paths[index]} does not exist`);
            }
            bodyFormData.append("filename", path.parse(args.paths[index]).base);
            bodyFormData.append("file", fs.readFileSync(args.paths[index]).toString());
        }
    });
}
function starknetInvokeAction(args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        yield starknetInvokeOrCallAction("invoke", args, hre);
    });
}
exports.starknetInvokeAction = starknetInvokeAction;
function starknetCallAction(args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        yield starknetInvokeOrCallAction("call", args, hre);
    });
}
exports.starknetCallAction = starknetCallAction;
function starknetInvokeOrCallAction(choice, args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const gatewayUrl = getGatewayUrl(args, hre);
        const contractFactory = yield hre.starknet.getContractFactory(args.contract, gatewayUrl);
        const abiPath = contractFactory.getAbiPath();
        let wallet, accountDir;
        if (args.wallet) {
            wallet = (0, extend_utils_1.getWalletUtil)(args.wallet, hre);
            accountDir = (0, utils_1.getAccountPath)(wallet.accountPath, hre);
        }
        const executed = yield hre.starknetWrapper.invokeOrCall({
            choice: choice,
            address: args.address,
            abi: abiPath,
            functionName: args.function,
            inputs: args.inputs ? args.inputs.split(/\s+/) : undefined,
            signature: args.signature,
            wallet: wallet ? wallet.modulePath : undefined,
            account: wallet ? wallet.accountName : undefined,
            accountDir: wallet ? accountDir : undefined,
            gatewayUrl: gatewayUrl,
            feederGatewayUrl: gatewayUrl,
            blockNumber: args.blockNumber ? args.blockNumber : undefined,
            networkID: wallet ? args.starknetNetwork : undefined
        });
        const statusCode = processExecuted(executed, true);
        if (statusCode) {
            const msg = `Could not ${choice} ${args.function}:\n` + executed.stderr.toString();
            const replacedMsg = (0, utils_1.adaptLog)(msg);
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, replacedMsg);
        }
        if (choice === "invoke" && args.wait) {
            // If the "wait" flag was passed as an argument, check the transaction hash for its status
            console.log(`Checking ${choice} transaction...`);
            const executedOutput = executed.stdout.toString();
            const txHash = (0, types_1.extractTxHash)(executedOutput);
            yield new Promise((resolve, reject) => (0, types_1.iterativelyCheckStatus)(txHash, hre.starknetWrapper, gatewayUrl, gatewayUrl, (status) => {
                console.log(`Invoke transaction ${txHash} is now ${status}`);
                resolve();
            }, (error) => {
                console.error(`Invoke transaction ${txHash} is REJECTED`);
                reject(error);
            }));
        }
    });
}
function starknetDeployAccountAction(args, hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const gatewayUrl = getGatewayUrl(args, hre);
        const wallet = (0, extend_utils_1.getWalletUtil)(args.wallet, hre);
        const accountDir = (0, utils_1.getAccountPath)(wallet.accountPath, hre);
        fs.mkdirSync(accountDir, { recursive: true });
        const executed = yield hre.starknetWrapper.deployAccount({
            accountDir: accountDir,
            accountName: wallet.accountName,
            feederGatewayUrl: gatewayUrl,
            gatewayUrl: gatewayUrl,
            network: args.starknetNetwork,
            wallet: wallet.modulePath
        });
        const statusCode = processExecuted(executed, true);
        if (statusCode) {
            const msg = "Could not deploy account contract:\n" + executed.stderr.toString();
            const replacedMsg = (0, utils_1.adaptLog)(msg);
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, replacedMsg);
        }
    });
}
exports.starknetDeployAccountAction = starknetDeployAccountAction;
/**
 * Used later on for network interaction.
 * @param args Hardhat CLI args
 * @param hre HardhatRuntimeEnvironment
 */
function setRuntimeNetwork(args, hre) {
    let networkName;
    let networkConfig;
    if (args.starknetNetwork) {
        networkName = args.starknetNetwork;
        networkConfig = (0, utils_1.getNetwork)(networkName, hre.config.networks, "--starknet-network");
    }
    else if (hre.config.starknet.network) {
        networkName = hre.config.starknet.network;
        networkConfig = (0, utils_1.getNetwork)(networkName, hre.config.networks, "starknet.network in hardhat.config");
    }
    else {
        networkName = constants_1.DEFAULT_STARKNET_NETWORK;
        networkConfig = (0, utils_1.getNetwork)(networkName, hre.config.networks, "default settings");
    }
    hre.config.starknet.network = hre.starknet.network = networkName;
    hre.config.starknet.networkUrl = hre.starknet.networkUrl = networkConfig.url;
    console.log(`Using network ${hre.starknet.network} at ${hre.starknet.networkUrl}`);
}
function starknetTestAction(args, hre, runSuper) {
    return __awaiter(this, void 0, void 0, function* () {
        setRuntimeNetwork(args, hre);
        yield runSuper(args);
    });
}
exports.starknetTestAction = starknetTestAction;
//# sourceMappingURL=task-actions.js.map